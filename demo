obtaining Kubernetes cluster API access
create K8s cluster using TKGIMC UI
use browser

SSH to TKGIMC VM
ssh root@((TKGIMC IP address))
Password: ((TKGIMC root password))

login to TKGI -> obtain K8s API creds -> access to K8s API
export TKGI_FQDN=((TKGI API FQDN)) #determined in TKGIMC configuration
export TKGI_ADMIN_PWD=((TKGI admin user password)) #automatically generated by TKGIMC
tkgi login -a $TKGI_FQDN -k -u admin -p $TKGI_ADMIN_PWD
tkgi clusters
tkgi get-credentials ((K8s cluster name))
kubectl cluster-info
kubectl get nodes -o wide
kubectl get all -A
2_check_harbor_access.md
checking Harbor access
SSH to TKGIMC VM
check Docker images in TKGIMC -> add Harbor CA cert to TKGIMC VM
export HARBOR_FQDN=((Harbor FQDN)) #determined in TKGIMC configuration
export HARBOR_ADMIN_PWD=((Harbor admin user password)) #determined in TKGIMC configuration
docker images
mkdir -p /etc/docker/certs.d/$HARBOR_FQDN/
cat <<EOF > /etc/docker/certs.d/$HARBOR_FQDN/ca.crt
((copy VMware Harbor Repository CA Certificate from TKGIMC UI and paste here))
EOF
ls -l /etc/docker/certs.d/$HARBOR_FQDN/ca.crt
docker login to Harbor -> push nginx Docker image to Harbor
docker login -u admin -p $HARBOR_ADMIN_PWD $HARBOR_FQDN
docker tag pks-frontend:latest $HARBOR_FQDN/library/nginx:latest
docker images
docker push $HARBOR_FQDN/library/nginx:latest
check nginx image on Harbor UI
use browser

3_run_nginx_pod.md
running a pod using nginx image in Harbor
SSH to TKGIMC VM
obtain K8s API access
add ConfigMaps for nginx pod
cat << EOF | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-conf
data:
  nginx.conf: |
    worker_processes 1;
    error_log /dev/stdout info;
    events {}
    http {
      log_format ltsv 'time:\$time_iso8601\t'
                      'remote_addr:\$remote_addr\t'
                      'protocol:\$server_protocol\t'
                      'scheme:\$scheme\t'
                      'host:\$host\t'
                      'request_method:\$request_method\t'
                      'request_uri:\$request_uri\t'
                      'request_length:\$request_length\t'
                      'user_agent:\$http_user_agent\t'
                      'referer:\$http_referer\t'
                      'x_forwarded_for:\$http_x_forwarded_for\t'
                      'status:\$status\t'
                      'body_bytes_sent:\$body_bytes_sent\t';
      access_log /dev/stdout ltsv;
      access_log /mnt/access.log ltsv;
      sendfile on;
      keepalive_timeout 65;
      proxy_temp_path /tmp/proxy_temp;
      client_body_temp_path /tmp/client_temp;
      fastcgi_temp_path /tmp/fastcgi_temp;
      uwsgi_temp_path /tmp/uwsgi_temp;
      scgi_temp_path /tmp/scgi_temp;
      server {
        listen 80 default_server;
        root /opt/nginx/html;
        index index.html;
      }
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-html
data:
  index.html: |
    <h1>Hello TKGI!</h1>
EOF
kubectl get cm
run nginx pod
export HARBOR_FQDN=((Harbor FQDN)) #determined in TKGIMC configuration
cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    run: nginx
spec:
  containers:
  - image: ${HARBOR_FQDN}/library/nginx:latest
    name: nginx
    volumeMounts:
    - mountPath: /etc/nginx
      readOnly: true
      name: nginx-conf
    - mountPath: /opt/nginx/html
      readOnly: true
      name: nginx-html
  volumes:
  - name: nginx-conf
    configMap:
      name: nginx-conf
      items:
      - key: nginx.conf
        path: nginx.conf
  - name: nginx-html
    configMap:
      name: nginx-html
      items:
      - key: index.html
        path: index.html
EOF

kubectl get pod
4_expose_nginx_via_lb.md
exposing nginx pod via NSX-T Load Balancer
SSH to TKGIMC VM
obtain K8s API access
create type:LoadBalancer service resource
cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: nginx-lb
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    run: nginx
  type: LoadBalancer
EOF

kubectl get svc

curl -v http://((external IP address))
kubectl logs nginx
check LB configuration on NSX manager UI
use browser

5_expose_nginx_via_ingress.md
exposing nginx pod via Ingress
SSH to TKGIMC VM
obtain K8s API access
create Ingress resource (HTTP)
cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: nginx
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    run: nginx
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: nginx-ingress
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx
            port:
              number: 80
EOF

kubectl get svc
kubectl get ingress

curl -v http://((ingress IP address))
kubectl logs nginx
create Ingress resource (HTTPS)
create self-signed cert with SAN
touch ~/.rnd &&\
  openssl req -newkey rsa:2048 -days 9999 \
  -nodes -x509 \
  -subj "/CN=((Domain Name))" \
  -extensions SAN \
  -config <( cat /etc/ssl/openssl.cnf \
    <(printf "[SAN]\nsubjectAltName='DNS:((Domain Name)),DNS:*.((Domain Name))'")) \
  -keyout server.key -out server.crt
create Secret resource to store cert
kubectl create secret tls tls-cert --cert=server.crt --key=server.key
kubectl get secret
create Ingress resource using Secret
cat << EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: nginx-ingress-https
spec:
  tls:
  - hosts:
    - ((Domain Name))
    secretName: tls-cert
  rules:
  - host: ((Domain Name))
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx
            port:
              number: 80
EOF

kubectl get svc
kubectl get ingress

curl -v --resolve ((Domain Name)):443:((ingress IP address)) https://((Domain Name))
kubectl logs nginx
6_test_netpol.md
applying Network Policy
SSH to TKGIMC VM
obtain K8s API access
create a pod 'pod1' without network policy
cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: pod1
  labels:
    role: pod1
spec:
  containers:
  - image: ${HARBOR_FQDN}/library/nginx:latest
    name: nginx
    volumeMounts:
    - mountPath: /etc/nginx
      readOnly: true
      name: nginx-conf
    - mountPath: /opt/nginx/html
      readOnly: true
      name: nginx-html
  volumes:
  - name: nginx-conf
    configMap:
      name: nginx-conf
      items:
      - key: nginx.conf
        path: nginx.conf
  - name: nginx-html
    configMap:
      name: nginx-html
      items:
      - key: index.html
        path: index.html
EOF

kubectl get pod
try egress connection from pod1 => accessible
kubectl get ingress

kubectl exec pod1 -- curl -v -m 5 http://((ingress IP address))
apply network policy which denies egress connection
cat << EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: denyallegress
spec:
  podSelector:
    matchLabels:
      role: pod1
  policyTypes:
  - Egress
EOF

kubectl get netpol
check Distributed Firewall configuration on NSX manager UI
use browser

try egress connection from pod1 => not accessible
kubectl get ingress

kubectl exec pod1 -- curl -v -m 5 http://((ingress IP address))
delete pod1 and network policy
kubectl delete netpol denyallegress
kubectl get netpol

kubectl delete pod pod1
kubectl get pod
7_test_pv.md
using Persistent Volume
SSH to TKGIMC VM
obtain K8s API access
define StorageClass, create PersistentVolumeClaim, and check PersistentVolume
cat << EOF | kubectl apply -f -
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: thin-disk
provisioner: kubernetes.io/vsphere-volume
---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: log-volume-claim
  annotations:
    volume.beta.kubernetes.io/storage-class: thin-disk
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
EOF

kubectl get sc
kubectl get pvc

kubectl get pv
change nginx Pod definition
kubectl delete pod nginx
cat << EOF > nginx-pod.yml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    run: nginx
spec:
  containers:
  - image: ${HARBOR_FQDN}/library/nginx:latest
    name: nginx
    volumeMounts:
    - mountPath: /etc/nginx
      readOnly: true
      name: nginx-conf
    - mountPath: /opt/nginx/html
      readOnly: true
      name: nginx-html
    - mountPath: /mnt
      name: nginx-log
  volumes:
  - name: nginx-conf
    configMap:
      name: nginx-conf
      items:
      - key: nginx.conf
        path: nginx.conf
  - name: nginx-html
    configMap:
      name: nginx-html
      items:
      - key: index.html
        path: index.html
  - name: nginx-log
    persistentVolumeClaim:
      claimName: log-volume-claim
EOF

kubectl apply -f nginx-pod.yml

kubectl get pod
kubectl exec -t nginx -- cat /mnt/access.log

curl -v http://((external IP address))
kubectl exec -t nginx -- cat /mnt/access.log
recreate nginx Pod, and check volume persistence
kubectl delete pod nginx
kubectl apply -f nginx-pod.yml

kubectl get pod
kubectl exec -t nginx -- cat /mnt/access.log

curl -v http://((external IP address))
kubectl exec -t nginx -- cat /mnt/access.log
check PV storage on vCenter UI
use browser

8_run_multiple_pods.md
running multiple pods as a Deployment
SSH to TKGIMC VM
obtain K8s API access
delete existing Pod
kubectl delete pod nginx
kubectl get pod
run 2 nginx Pods as a Deployment
cat << EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  replicas: 2
  selector:
    matchLabels:
      run: nginx
  template:
    metadata:
      labels:
        run: nginx
    spec:
      containers:
      - image: ${HARBOR_FQDN}/library/nginx:latest
        name: nginx
        volumeMounts:
        - mountPath: /etc/nginx
          readOnly: true
          name: nginx-conf
        - mountPath: /opt/nginx/html
          readOnly: true
          name: nginx-html
      volumes:
      - name: nginx-conf
        configMap:
          name: nginx-conf
          items:
          - key: nginx.conf
            path: nginx.conf
      - name: nginx-html
        configMap:
          name: nginx-html
          items:
          - key: index.html
            path: index.html
EOF

kubectl get deploy
kubectl get pod
kubectl describe deploy nginx

curl -v http://((ingress IP address))
curl -v http://((LB external IP address))
99_cleanup.md
SSH to TKGIMC VM
obtain K8s API access
clean up K8s objects
kubectl get ingress
kubectl delete ingress nginx-ingress
kubectl get ingress
kubectl delete svc nginx-lb
kubectl delete svc nginx
kubectl get svc

kubectl get deploy
kubectl delete deploy nginx
kubectl get deploy

kubectl get pod
kubectl delete pod nginx
kubectl delete pod pod1
kubectl delete pod pod2
kubectl get pod

kubectl get secret
kubectl delete secret regsecret
kubectl get secret

kubectl get pvc
kubectl get pv
kubectl delete pvc log-volume-claim
kubectl get pvc
kubectl get pv
destroy K8s cluster using TKGIMC UI
tkgi CLI can also be used to destroy K8s cluster
delete nginx image from Harbor
delete nginx image tag from TKGIMC
docker rmi $HARBOR_FQDN/testprivate/nginx:latest
docker rmi $HARBOR_FQDN/library/nginx:latest
9_harbor_private_registry.md
using Harbor private registry
SSH to TKGIMC VM
create a private project testprivate in Harbor
use browser

push nginx image to the private project
docker login -u admin -p $HARBOR_ADMIN_PWD $HARBOR_FQDN
docker tag pks-frontend:latest $HARBOR_FQDN/testprivate/nginx:latest
docker images
docker push $HARBOR_FQDN/testprivate/nginx:latest
check the private project testprivate in Harbor
use browser

create a robot account testrobot in the private project
use browser

obtain K8s API access
create secret for the robot account in Kubernetes cluster
kubectl create secret docker-registry regsecret \
  --docker-server=https://$HARBOR_FQDN \
  --docker-username='robot$testrobot' \
  --docker-password='((robot account token))'

kubectl get secret
run a pod using nginx image and robot account secret of the private Harbor project
cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: pod1
spec:
  containers:
  - image: ${HARBOR_FQDN}/testprivate/nginx:latest
    name: nginx
    volumeMounts:
    - mountPath: /etc/nginx
      readOnly: true
      name: nginx-conf
    - mountPath: /opt/nginx/html
      readOnly: true
      name: nginx-html
  imagePullSecrets:
  - name: regsecret
  volumes:
  - name: nginx-conf
    configMap:
      name: nginx-conf
      items:
      - key: nginx.conf
        path: nginx.conf
  - name: nginx-html
    configMap:
      name: nginx-html
      items:
      - key: index.html
        path: index.html
EOF

kubectl get pod
try to run a nginx pod without robot account secret
cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: pod2
spec:
  containers:
  - image: ${HARBOR_FQDN}/testprivate/nginx:latest
    name: nginx
    volumeMounts:
    - mountPath: /etc/nginx
      readOnly: true
      name: nginx-conf
    - mountPath: /opt/nginx/html
      readOnly: true
      name: nginx-html
  volumes:
  - name: nginx-conf
    configMap:
      name: nginx-conf
      items:
      - key: nginx.conf
        path: nginx.conf
  - name: nginx-html
    configMap:
      name: nginx-html
      items:
      - key: index.html
        path: index.html
EOF

kubectl get pod
kubectl describe pod pod2
